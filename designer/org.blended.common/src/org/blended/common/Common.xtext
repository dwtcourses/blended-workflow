grammar org.blended.common.Common with org.eclipse.xtext.common.Terminals

generate common "http://www.blended.org/common/Common"

BlendedModel:
	expressions += Expression+
;

Nothing:
	name = 'nothing'
;

Specification:
	'Specification' ':' name = STRING
;

Entity:
	'Entity' name = ID (exists ?= 'exists')? ('dependsOn' dependsOn += QualifiedName (',' dependsOn += QualifiedName)*)? '{' 
		attributes += Attribute*
		constraint += Constraint*
	'}'
;

Attribute:
	name = QualifiedName ':' type = ID
	(mandatory ?= 'mandatory')?
	('dependsOn' dependsOn += QualifiedName (',' dependsOn += QualifiedName)*)?
;

QualifiedName: 
	ID ('.' ID)*
;

Association:
	'Association' name = ID '{'
		entity1 = [Entity] 'with' name1 = QualifiedName  '(' cardinality1 = Cardinality ')'
		entity2 = [Entity] 'with' name2 = QualifiedName '(' cardinality2 = Cardinality ')'
	'}'
;

Constraint:
	'Constraint' name = ID ':' constraint = Expression
;

EntityAchieveCondition:
	'EDEF' '(' name = QualifiedName ')'
;

EntityAchieveConditionExist:
	'EXISTS' '(' 'EDEF' '(' name = QualifiedName ')' ')'
;

EntityInvariantCondition:
	'MUL' '(' name = QualifiedName ',' cardinality = Cardinality ')'
;

EntityDependenceCondition:
	'DEP' '(' 'EDEF' '(' entity1 = QualifiedName ')' ',' 'EDEF' '(' entity2 = QualifiedName ')' ')'
;

AttributeAchieveCondition:
	MandatoryAttributeAchieveCondition | NotMandatoryAttributeAchieveCondition
;

NotMandatoryAttributeAchieveCondition:
	'ADEF' '(' attribute = QualifiedName ')' 
;

MandatoryAttributeAchieveCondition:
	'MAN' '(' 'ADEF' '(' attribute = QualifiedName ')' ')'
;

AttributeInvariantCondition:
	'RULE' '(' context = ID ',' name = ID ')' '=' '(' expression = Expression ')'
;

AttributeDependenceCondition:
	'DEP' '(' 'ADEF' '(' attribute1 = QualifiedName ')' 
		',' 'ADEF' '(' attribute2 = QualifiedName ')'  
	')'
;

Cardinality:
	INT | INT '..' INT | INT '..' '*' | INT '..' '+'
;

PathDefinition:
	'DEF' '(' path = QualifiedName ')'
;

Expression: Or;

Or returns Expression:
	And (
		{Or.left = current} 'OR' right = And
	)*;	
	
And returns Expression:
	Equality (
		{And.left = current} 'AND' right = Equality
	)*;	
	
Equality returns Expression:
	Comparison (
		({Equal.left=current} '==' | {NotEqual.left=current} '!=') 
		right=Comparison
	)*;	
	
Comparison returns Expression:
	PlusOrMinus (
		({GreaterEqual.left=current} '>=' | {Greater.left=current} '>' | {SmallerEqual.left=current} '<=' | {Smaller.left=current} '<') 
		right=PlusOrMinus
	)*;	

PlusOrMinus returns Expression:
	MulOrDiv (
		({Plus.left=current} '+' | {Minus.left=current} '-') 
		right=MulOrDiv
	)*;	

MulOrDiv returns Expression:
	Primary (
		({Mul.left=current} '*' | {Div.left=current} '/') 
		right=Primary
	)*;	

//MulOrDiv returns Expression:
//	Primary (
//		{MulOrDiv.left=current} op=('*'|'/') 
//		right=Primary
//	)*;	

Primary returns Expression:
	'(' Expression ')' | 
	{Not} 'NOT' expression = Primary |
	Atomic
;

Atomic returns Expression:
	{AttributeValue} name = QualifiedName |
	{IntConstant} name=INT |
	{StringConstant} name=STRING |
	{BoolConstant} name=('true'|'false')
;