/*
 * generated by Xtext
 */
package org.blended.data.serializer;

import com.google.inject.Inject;
import com.google.inject.Provider;
import org.blended.data.data.And;
import org.blended.data.data.Association;
import org.blended.data.data.Attribute;
import org.blended.data.data.AttributeDefinition;
import org.blended.data.data.AttributeGroup;
import org.blended.data.data.AttributeValue;
import org.blended.data.data.Constraint;
import org.blended.data.data.DataModel;
import org.blended.data.data.DataPackage;
import org.blended.data.data.Entity;
import org.blended.data.data.Not;
import org.blended.data.data.Or;
import org.blended.data.services.DataGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class DataSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private DataGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == DataPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case DataPackage.AND:
				sequence_And(context, (And) semanticObject); 
				return; 
			case DataPackage.ASSOCIATION:
				sequence_Association(context, (Association) semanticObject); 
				return; 
			case DataPackage.ATTRIBUTE:
				sequence_Attribute(context, (Attribute) semanticObject); 
				return; 
			case DataPackage.ATTRIBUTE_DEFINITION:
				sequence_Atomic(context, (AttributeDefinition) semanticObject); 
				return; 
			case DataPackage.ATTRIBUTE_GROUP:
				sequence_AttributeGroup(context, (AttributeGroup) semanticObject); 
				return; 
			case DataPackage.ATTRIBUTE_VALUE:
				sequence_Atomic(context, (AttributeValue) semanticObject); 
				return; 
			case DataPackage.CONSTRAINT:
				sequence_Constraint(context, (Constraint) semanticObject); 
				return; 
			case DataPackage.DATA_MODEL:
				sequence_DataModel(context, (DataModel) semanticObject); 
				return; 
			case DataPackage.ENTITY:
				sequence_Entity(context, (Entity) semanticObject); 
				return; 
			case DataPackage.NOT:
				sequence_Primary(context, (Not) semanticObject); 
				return; 
			case DataPackage.OR:
				sequence_Or(context, (Or) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     (left=And_And_1_0 right=Primary)
	 */
	protected void sequence_And(EObject context, And semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, DataPackage.Literals.AND__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DataPackage.Literals.AND__LEFT));
			if(transientValues.isValueTransient(semanticObject, DataPackage.Literals.AND__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DataPackage.Literals.AND__RIGHT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getAndAccess().getAndLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAndAccess().getRightPrimaryParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         entity1=[Entity|ID] 
	 *         name1=ID 
	 *         cardinality1=Cardinality 
	 *         entity2=[Entity|ID] 
	 *         name2=ID 
	 *         cardinality2=Cardinality
	 *     )
	 */
	protected void sequence_Association(EObject context, Association semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, DataPackage.Literals.ASSOCIATION__ENTITY1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DataPackage.Literals.ASSOCIATION__ENTITY1));
			if(transientValues.isValueTransient(semanticObject, DataPackage.Literals.ASSOCIATION__NAME1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DataPackage.Literals.ASSOCIATION__NAME1));
			if(transientValues.isValueTransient(semanticObject, DataPackage.Literals.ASSOCIATION__CARDINALITY1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DataPackage.Literals.ASSOCIATION__CARDINALITY1));
			if(transientValues.isValueTransient(semanticObject, DataPackage.Literals.ASSOCIATION__ENTITY2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DataPackage.Literals.ASSOCIATION__ENTITY2));
			if(transientValues.isValueTransient(semanticObject, DataPackage.Literals.ASSOCIATION__NAME2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DataPackage.Literals.ASSOCIATION__NAME2));
			if(transientValues.isValueTransient(semanticObject, DataPackage.Literals.ASSOCIATION__CARDINALITY2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DataPackage.Literals.ASSOCIATION__CARDINALITY2));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getAssociationAccess().getEntity1EntityIDTerminalRuleCall_2_0_1(), semanticObject.getEntity1());
		feeder.accept(grammarAccess.getAssociationAccess().getName1IDTerminalRuleCall_4_0(), semanticObject.getName1());
		feeder.accept(grammarAccess.getAssociationAccess().getCardinality1CardinalityParserRuleCall_6_0(), semanticObject.getCardinality1());
		feeder.accept(grammarAccess.getAssociationAccess().getEntity2EntityIDTerminalRuleCall_8_0_1(), semanticObject.getEntity2());
		feeder.accept(grammarAccess.getAssociationAccess().getName2IDTerminalRuleCall_10_0(), semanticObject.getName2());
		feeder.accept(grammarAccess.getAssociationAccess().getCardinality2CardinalityParserRuleCall_12_0(), semanticObject.getCardinality2());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     name=QualifiedName
	 */
	protected void sequence_Atomic(EObject context, AttributeDefinition semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, DataPackage.Literals.ATTRIBUTE_DEFINITION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DataPackage.Literals.ATTRIBUTE_DEFINITION__NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getAtomicAccess().getNameQualifiedNameParserRuleCall_0_3_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     name=QualifiedName
	 */
	protected void sequence_Atomic(EObject context, AttributeValue semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, DataPackage.Literals.ATTRIBUTE_VALUE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DataPackage.Literals.ATTRIBUTE_VALUE__NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getAtomicAccess().getNameQualifiedNameParserRuleCall_1_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (mandatory?='mandatory'? (dependsOn+=[Attribute|QualifiedName] dependsOn+=[Attribute|QualifiedName]*)? attributes+=Attribute+)
	 */
	protected void sequence_AttributeGroup(EObject context, AttributeGroup semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=QualifiedName type=ID mandatory?='mandatory'? (dependsOn+=[Attribute|QualifiedName] dependsOn+=[Attribute|QualifiedName]*)?)
	 */
	protected void sequence_Attribute(EObject context, Attribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     constraint=Expression
	 */
	protected void sequence_Constraint(EObject context, Constraint semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, DataPackage.Literals.CONSTRAINT__CONSTRAINT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DataPackage.Literals.CONSTRAINT__CONSTRAINT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getConstraintAccess().getConstraintExpressionParserRuleCall_2_0(), semanticObject.getConstraint());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (entities+=Entity* associations+=Association* constraint+=Constraint*)
	 */
	protected void sequence_DataModel(EObject context, DataModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID exists?='exists'? dependsOn=[Entity|ID]? (attributes+=AttributeGroup | attributes+=Attribute)*)
	 */
	protected void sequence_Entity(EObject context, Entity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (left=Or_Or_1_0 right=And)
	 */
	protected void sequence_Or(EObject context, Or semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, DataPackage.Literals.OR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DataPackage.Literals.OR__LEFT));
			if(transientValues.isValueTransient(semanticObject, DataPackage.Literals.OR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DataPackage.Literals.OR__RIGHT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getOrAccess().getOrLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getOrAccess().getRightAndParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     expression=Primary
	 */
	protected void sequence_Primary(EObject context, Not semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, DataPackage.Literals.NOT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DataPackage.Literals.NOT__EXPRESSION));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getPrimaryAccess().getExpressionPrimaryParserRuleCall_1_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
}
